<Type Name="AvoidVisibleConstantFieldRule" FullName="Gendarme.Rules.BadPractice.AvoidVisibleConstantFieldRule">
  <TypeSignature Language="C#" Value="public class AvoidVisibleConstantFieldRule : Gendarme.Framework.Rule, Gendarme.Framework.ITypeRule" />
  <AssemblyInfo>
    <AssemblyName>Gendarme.Rules.BadPractice</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Gendarme.Framework.Rule</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Gendarme.Framework.ITypeRule</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Gendarme.Framework.Solution("Use a 'static readonly' field (C# syntax) to make sure a reference to the field itself is kept and avoid recompiling all assemblies.")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Gendarme.Framework.Problem("This type contains visible field constants where the value will be embedded into the assemblies that use it.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
            This rule looks for constant fields that are visible outside the current assembly.
            Such fields, if used outside the assemblies, will have their value (not the field
            reference) copied into the other assembly. Changing the value will requires to
            recompile all assemblies in order to have the desired effect. Declaring the field
            as <c>static readonly</c> will have the desired effect (i.e. insert a reference to
            the field in its original assembly).
            </summary>
    <remarks>This rule is available since Gendarme 2.0</remarks>
    <example>
            Bad example:
            <code>
            // if this fields is used inside another assembly then
            // the integer 42, not the field, will be part of it
            public const int MagicNumber = 42;
            </code></example>
    <example>
            Good example:
            <code>
            // if this fields is used inside another assembly then
            // the MagicNumber will be referenced
            static public readonly int MagicNumber = 42;
            </code></example>
    <example>
            Bad example:
            <code>
            // if this fields is used inside another assembly then
            // the integer 42, not the field, will be part of it
            public const int MagicNumber = 42;
            </code></example>
    <example>
            Good example:
            <code>
            // if this fields is used inside another assembly then
            // the MagicNumber will be referenced
            static public readonly int MagicNumber = 42;
            </code></example>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AvoidVisibleConstantFieldRule ();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckType">
      <MemberSignature Language="C#" Value="public Gendarme.Framework.RuleResult CheckType (Mono.Cecil.TypeDefinition type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Gendarme.Framework.RuleResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="Mono.Cecil.TypeDefinition" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
