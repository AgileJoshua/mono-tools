<Type Name="AvoidSpeculativeGeneralityRule" FullName="Gendarme.Rules.Smells.AvoidSpeculativeGeneralityRule">
  <TypeSignature Language="C#" Value="public class AvoidSpeculativeGeneralityRule : Gendarme.Framework.Rule, Gendarme.Framework.ITypeRule" />
  <AssemblyInfo>
    <AssemblyName>Gendarme.Rules.Smells</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Gendarme.Framework.Rule</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Gendarme.Framework.ITypeRule</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Gendarme.Framework.Solution("You can apply various refactorings: Collapse Hierarchy, Inline Class, Remove Parameter or Rename Method.")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Gendarme.Framework.Problem("If you will need the feature in the future then you should implement it in the future.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
            This rule allows developers to avoid the Speculative Generality smell.
            Be carefull if you are developing a new framework or a new library,
            because this rule only inspect the assembly, then if you provide an
            abstract base class for extend by thrid party people, then the rule
            can warn you. You can ignore the message in this special case.
            We can detect this kind of smell looking for some points:
            <list type="bullet"><item><description>Abstract classes without responsability</description></item><item><description>Unnecesary delegation.</description></item><item><description>Unused parameters.</description></item></list></summary>
    <remarks>To be added.</remarks>
    <example>
            Bad example:
            An abstract class with only one subclass.
            <code>
            public abstract class AbstractClass {
            	public abstract void MakeStuff ();
            }
            public class OverriderClass : AbstractClass {
            	public override void MakeStuff ()
            	{
            	}
            }
            </code>
            If you use Telephone class only in one client, perhaps you don't need this kind of delegation.
            <code>
            public class Person {
            	int age;
            	string name;
            	Telephone phone;
            }
            public class Telephone {
            	int areaCode;
            	int phone;
            }
            </code></example>
    <example>
            Good example:
            <code>
            public abstract class OtherAbstractClass{
            	public abstract void MakeStuff ();
            }
            public class OtherOverriderClass : OtherAbstractClass {
            	public override void MakeStuff ()
            	{
            	}
            }
            public class YetAnotherOverriderClass : OtherAbstractClass {
            	public override void MakeStuff ()
            	{
            	}
            }
            </code></example>
    <example>
            Bad example:
            An abstract class with only one subclass.
            <code>
            public abstract class AbstractClass {
            	public abstract void MakeStuff ();
            }
            public class OverriderClass : AbstractClass {
            	public override void MakeStuff ()
            	{
            	}
            }
            </code>
            If you use Telephone class only in one client, perhaps you don't need this kind of delegation.
            <code>
            public class Person {
            	int age;
            	string name;
            	Telephone phone;
            }
            public class Telephone {
            	int areaCode;
            	int phone;
            }
            </code></example>
    <example>
            Good example:
            <code>
            public abstract class OtherAbstractClass{
            	public abstract void MakeStuff ();
            }
            public class OtherOverriderClass : OtherAbstractClass {
            	public override void MakeStuff ()
            	{
            	}
            }
            public class YetAnotherOverriderClass : OtherAbstractClass {
            	public override void MakeStuff ()
            	{
            	}
            }
            </code></example>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AvoidSpeculativeGeneralityRule ();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckType">
      <MemberSignature Language="C#" Value="public Gendarme.Framework.RuleResult CheckType (Mono.Cecil.TypeDefinition type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Gendarme.Framework.RuleResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="Mono.Cecil.TypeDefinition" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CountInheritedClassesFrom">
      <MemberSignature Language="C#" Value="public int CountInheritedClassesFrom (Mono.Cecil.TypeDefinition baseType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseType" Type="Mono.Cecil.TypeDefinition" />
      </Parameters>
      <Docs>
        <param name="baseType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public override void Initialize (Gendarme.Framework.IRunner runner);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="runner" Type="Gendarme.Framework.IRunner" />
      </Parameters>
      <Docs>
        <param name="runner">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
