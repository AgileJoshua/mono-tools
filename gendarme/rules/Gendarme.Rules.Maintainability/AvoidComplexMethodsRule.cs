//
// Gendarme.Rules.Maintainability.AvoidComplexMethodsRule class
//
// Authors:
//	Cedric Vivier <cedricv@neonux.com>
//
// 	(C) 2008 Cedric Vivier
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using System;
using System.Collections.Generic;

using Mono.Cecil;
using Mono.Cecil.Cil;

using Gendarme.Framework;
using Gendarme.Framework.Helpers;
using Gendarme.Framework.Rocks;

namespace Gendarme.Rules.Maintainability {

	/// <summary>
	/// This rule compute the cyclomatic complexity (CC) for every method and report any method
	/// with a CC over 25 (this limit is configurable). Large CC value often indicate complex
	/// code that will be hard to understand and maintain. It's likely that breaking down the
	/// method into several methods would help readability. This rule won't report any defects
	/// on code generated by the compiler or by tools.
	/// </summary>
	/// <remarks>This rule is available since Gendarme 2.0</remarks>

	[Problem ("Methods with a cyclomatic complexity equal or greater than 25 are harder to understand and maintain.")]
	[Solution ("You should apply an Extract Method refactoring, but there are other solutions.")]
	[FxCopCompatibility ("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
	public class AvoidComplexMethodsRule : Rule, IMethodRule {

		static OpCodeBitmask load = new OpCodeBitmask (0xFFFF6C3FC, 0x1B0300000000FFE0, 0x400100FFF800, 0xDE0);

		// defaults match fxcop rule http://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=1575061&SiteID=1
		// so people using both tools should not see conflicting results
		public AvoidComplexMethodsRule ()
		{
			SuccessThreshold = 25;
		}

		public override void Initialize (IRunner runner)
		{
			base.Initialize (runner);

			// works if only SuccessThreshold is configured in rules.xml
			if (LowThreshold == 0)
				LowThreshold = SuccessThreshold * 2;
			if (MediumThreshold == 0)
				MediumThreshold = SuccessThreshold * 3;
			if (HighThreshold == 0)
				HighThreshold = SuccessThreshold * 4;
		}

		public int SuccessThreshold { get; set; }

		public int LowThreshold { get; set; }

		public int MediumThreshold { get; set; }

		public int HighThreshold { get; set; }

	
		public RuleResult CheckMethod (MethodDefinition method)
		{
			//does rule apply?
			if (!method.HasBody || method.IsGeneratedCode () || method.IsCompilerControlled)
				return RuleResult.DoesNotApply;

			//yay! rule do apply!

			// quick optimization: if the number of instructions is lower
			// than our SuccessThreshold then it cannot be too complex
			if (method.Body.Instructions.Count < SuccessThreshold)
				return RuleResult.Success;

			int cc = GetCyclomaticComplexityForMethod(method);
			if (cc < SuccessThreshold)
				return RuleResult.Success;

			//how's severity?
			Severity sev = GetCyclomaticComplexitySeverity(cc);

			Runner.Report (method, sev, Confidence.High, String.Format ("Method's cyclomatic complexity : {0}.", cc));
			return RuleResult.Failure;
		}

		public Severity GetCyclomaticComplexitySeverity(int cc)
		{
			// 25 <= CC < 50 is not good but not catastrophic either
			if (cc < LowThreshold)
				return Severity.Low;
			// 50 <= CC < 75 this should be refactored asap
			if (cc < MediumThreshold)
				return Severity.Medium;
			// 75 <= CC < 100 this SHOULD be refactored asap
			if (cc < HighThreshold)
				return Severity.High;
			// CC > 100, don't touch it since it may become a classic in textbooks 
			// anyway probably no one can understand it ;-)
			return Severity.Critical;
		}

		public int GetCyclomaticComplexityForMethod (MethodDefinition method)
		{
			if ((method == null) || !method.HasBody)
				return 1;

			int cc = 1;

			foreach (Instruction inst in method.Body.Instructions)
			{
				if (FlowControl.Branch == inst.OpCode.FlowControl)
				{
					//detect ternary pattern
					if ((null != inst) && (null != inst.Previous) && load.Get (inst.Previous.OpCode.Code))
						cc++;
				}
				if (FlowControl.Cond_Branch != inst.OpCode.FlowControl)
				{
					continue;
				}

				if (inst.OpCode.Code == Code.Switch)
				{
					cc += GetNumberOfSwitchTargets(inst);
				}
				else //'normal' conditional branch
				{
					cc++;
				}
			}

			return cc;
		}

		List<Instruction> targets = new List<Instruction> ();

		private int GetNumberOfSwitchTargets (Instruction inst)
		{
			targets.Clear ();
			foreach (Instruction target in ((Instruction[]) inst.Operand))
			{
				if (!targets.Contains (target))
				{
					targets.Add (target);
				}
			}
			int nTargets = targets.Count;
			//detect 'default' branch
			if (FlowControl.Branch == inst.Next.OpCode.FlowControl)
			{
				if (inst.Next.Operand != FindFirstUnconditionalBranchTarget (targets[0]))
				{
					nTargets++;
				}
			}
			return nTargets;
		}

		private static Instruction FindFirstUnconditionalBranchTarget(Instruction inst)
		{
			while (null != inst)
			{
				if (FlowControl.Branch == inst.OpCode.FlowControl)
				{
					return ((Instruction) inst.Operand);
				}
				inst = inst.Next;
			}
			return null;
		}
#if false
		public void Bitmask ()
		{
			OpCodeBitmask mask = new OpCodeBitmask ();
			mask.Set (Code.Ldarg);
			mask.Set (Code.Ldarg_S);
			mask.Set (Code.Ldarg_0);
			mask.Set (Code.Ldarg_1);
			mask.Set (Code.Ldarg_2);
			mask.Set (Code.Ldarg_3);
			mask.Set (Code.Ldarga);
			mask.Set (Code.Ldarga_S);
			mask.Set (Code.Ldc_I4);
			mask.Set (Code.Ldc_I4_0);
			mask.Set (Code.Ldc_I4_1);
			mask.Set (Code.Ldc_I4_2);
			mask.Set (Code.Ldc_I4_3);
			mask.Set (Code.Ldc_I4_4);
			mask.Set (Code.Ldc_I4_5);
			mask.Set (Code.Ldc_I4_6);
			mask.Set (Code.Ldc_I4_7);
			mask.Set (Code.Ldc_I4_8);
			mask.Set (Code.Ldc_I4_M1);
			mask.Set (Code.Ldc_I4_S);
			mask.Set (Code.Ldc_I8);
			mask.Set (Code.Ldc_R4);
			mask.Set (Code.Ldc_R8);
			mask.Set (Code.Ldelem_Any);
			mask.Set (Code.Ldelem_I);
			mask.Set (Code.Ldelem_I1);
			mask.Set (Code.Ldelem_I2);
			mask.Set (Code.Ldelem_I4);
			mask.Set (Code.Ldelem_I8);
			mask.Set (Code.Ldelem_R4);
			mask.Set (Code.Ldelem_R8);
			mask.Set (Code.Ldelem_Ref);
			mask.Set (Code.Ldelem_U1);
			mask.Set (Code.Ldelem_U2);
			mask.Set (Code.Ldelem_U4);
			mask.Set (Code.Ldelema);
			mask.Set (Code.Ldfld);
			mask.Set (Code.Ldflda);
			mask.Set (Code.Ldftn);
			mask.Set (Code.Ldind_I);
			mask.Set (Code.Ldind_I1);
			mask.Set (Code.Ldind_I2);
			mask.Set (Code.Ldind_I4);
			mask.Set (Code.Ldind_I8);
			mask.Set (Code.Ldind_R4);
			mask.Set (Code.Ldind_R8);
			mask.Set (Code.Ldind_Ref);
			mask.Set (Code.Ldind_U1);
			mask.Set (Code.Ldind_U2);
			mask.Set (Code.Ldind_U4);
			mask.Set (Code.Ldlen);
			mask.Set (Code.Ldloc);
			mask.Set (Code.Ldloc_0);
			mask.Set (Code.Ldloc_1);
			mask.Set (Code.Ldloc_2);
			mask.Set (Code.Ldloc_3);
			mask.Set (Code.Ldloc_S);
			mask.Set (Code.Ldloca);
			mask.Set (Code.Ldloca_S);
			mask.Set (Code.Ldnull);
			mask.Set (Code.Ldobj);
			mask.Set (Code.Ldsfld);
			mask.Set (Code.Ldsflda);
			mask.Set (Code.Ldstr);
			mask.Set (Code.Ldtoken);
			mask.Set (Code.Ldvirtftn);
			Console.WriteLine (mask);
		}
#endif
	}
}

