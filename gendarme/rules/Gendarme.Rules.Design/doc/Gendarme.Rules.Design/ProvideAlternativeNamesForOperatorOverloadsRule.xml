<Type Name="ProvideAlternativeNamesForOperatorOverloadsRule" FullName="Gendarme.Rules.Design.ProvideAlternativeNamesForOperatorOverloadsRule">
  <TypeSignature Language="C#" Value="public class ProvideAlternativeNamesForOperatorOverloadsRule : Gendarme.Framework.Rule, Gendarme.Framework.ITypeRule" />
  <AssemblyInfo>
    <AssemblyName>Gendarme.Rules.Design</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Gendarme.Framework.Rule</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Gendarme.Framework.ITypeRule</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Gendarme.Framework.FxCopCompatibility("Microsoft.Usage", "CA2225:OperatorOverloadsHaveNamedAlternates")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Gendarme.Framework.Solution("Add named methods equivalent to the operators for language that do not support them (e.g. VB.NET).")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Gendarme.Framework.Problem("This type contains overloads for some operators but doesn't provide named alternatives.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
            The rule ensure that all overloaded operators are also accessible used named
            alternatives because some languages, like VB.NET, cannot use overloaded operators.
            For those languages named methods should be implemented that provide the same
            functionality. This rule checks for a named alternative for each overloaded operator.
            <list type="bullet"><item>op_UnaryPlus</item><description>Plus</description><item>op_UnaryNegation</item><description>Negate</description><item>op_LogicalNot</item><description>LogicalNot</description><item>op_OnesComplement</item><description>OnesComplement</description></list><list type="bullet"><item>op_Increment</item><description>Increment</description><item>op_Decrement</item><description>Decrement</description><item>op_True</item><description>IsTrue</description><item>op_False</item><description>IsFalse</description></list><list type="bullet"><item>op_Addition</item><description>Add</description><item>op_Subtraction</item><description>Subtract</description><item>op_Multiply</item><description>Multiply</description><item>op_Division</item><description>Divide</description><item>op_Modulus</item><description>Modulus</description></list><list type="bullet"><item>op_BitwiseAnd</item><description>BitwiseAnd</description><item>op_BitwiseOr</item><description>BitwiseOr</description><item>op_ExclusiveOr</item><description>ExclusiveOr</description></list><list type="bullet"><item>op_LeftShift</item><description>LeftShift</description><item>op_RightShift</item><description>RightShift</description></list><list type="bullet"><item>op_Equality</item><description>Equals</description><item>op_Inequality</item><description>(not) Equals</description><item>op_GreaterThan</item><description>Compare</description><item>op_LessThan</item><description>Compare</description><item>op_GreaterThanOrEqual</item><description>Compare</description><item>op_LessThanOrEqual</item><description>Compare</description></list></summary>
    <remarks>To be added.</remarks>
    <example>
            Bad example:
            <code>
            class DoesNotImplementAlternative {
            	public static int operator + (DoesNotOverloadOperatorEquals a, DoesNotOverloadOperatorEquals b)
            	{
            		return 0;
            	}
            }
            </code></example>
    <example>
            Good example:
            <code>
            class DoesImplementAdd {
            	public static int operator + (DoesImplementAdd a, DoesImplementAdd b)
            	{
            		return 0;
            	}
            	public int Add (DoesImplementAdd a)
            	{
            		return this + a;
            	}
            }
            </code></example>
    <example>
            Bad example:
            <code>
            class DoesNotImplementAlternative {
            	public static int operator + (DoesNotOverloadOperatorEquals a, DoesNotOverloadOperatorEquals b)
            	{
            		return 0;
            	}
            }
            </code></example>
    <example>
            Good example:
            <code>
            class DoesImplementAdd {
            	public static int operator + (DoesImplementAdd a, DoesImplementAdd b)
            	{
            		return 0;
            	}
            	public int Add (DoesImplementAdd a)
            	{
            		return this + a;
            	}
            }
            </code></example>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProvideAlternativeNamesForOperatorOverloadsRule ();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckType">
      <MemberSignature Language="C#" Value="public Gendarme.Framework.RuleResult CheckType (Mono.Cecil.TypeDefinition type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Gendarme.Framework.RuleResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="Mono.Cecil.TypeDefinition" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
