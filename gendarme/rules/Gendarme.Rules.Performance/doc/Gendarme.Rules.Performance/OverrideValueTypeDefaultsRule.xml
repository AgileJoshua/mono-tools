<Type Name="OverrideValueTypeDefaultsRule" FullName="Gendarme.Rules.Performance.OverrideValueTypeDefaultsRule">
  <TypeSignature Language="C#" Value="public class OverrideValueTypeDefaultsRule : Gendarme.Framework.Rule, Gendarme.Framework.ITypeRule" />
  <AssemblyInfo>
    <AssemblyName>Gendarme.Rules.Performance</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Gendarme.Framework.Rule</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Gendarme.Framework.ITypeRule</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Gendarme.Framework.FxCopCompatibility("Microsoft.Performance", "CA1815:OverrideEqualsAndOperatorEqualsOnValueTypes")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Gendarme.Framework.Solution("To avoid performance penalities of the default implementations you should override, or implement, the specified methods.")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Gendarme.Framework.Problem("This type does not override the default ValueType implementation of Equals(object) and GetHashCode() which lacks performance due to their generalized design.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
            This rule checks all value types, except enumerations, to see if they use the default
            implementation of <c>Equals(object)</c> and <c>GetHashCode()</c> methods. While
            <c>ValueType</c> implementations work for any value type they do so at the expense of
            performance (since it must reflect all fields). You can easily override both methods
            with much faster code since you know all meaningful fields inside your structure.
            At the same time you should also provide, if your language allows it, operator overloads
            for equality (<c>op_Equality</c>, <c>==</c>) and inequality (<c>op_Inequality</c>,
            <c>!=</c>).
            </summary>
    <remarks>This rule is available since Gendarme 2.0</remarks>
    <example>
            Bad example:
            <code>
            public struct Coord {
            	int X, Y, Z;
            }
            </code></example>
    <example>
            Good example:
            <code>
            public struct Coord {
            	int X, Y, Z;
            	public override bool Equals (object obj)
            	{
            		if (obj == null) {
            			return false;
            		}
            		Coord c = (Coord)obj;
            		return ((X == c.X) &amp;&amp; (Y == c.Y) &amp;&amp; (Z == c.Z));
            	}
            	public override int GetHashCode ()
            	{
            		return X ^ Y ^ Z;
            	}
            	public static bool operator == (Coord left, Coord right)
            	{
            		return left.Equals (right);
            	}
            	public static bool operator != (Coord left, Coord right)
            	{
            		return !left.Equals (right);
            	}
            }
            </code></example>
    <example>
            Bad example:
            <code>
            public struct Coord {
            	int X, Y, Z;
            }
            </code></example>
    <example>
            Good example:
            <code>
            public struct Coord {
            	int X, Y, Z;
            	public override bool Equals (object obj)
            	{
            		if (obj == null) {
            			return false;
            		}
            		Coord c = (Coord)obj;
            		return ((X == c.X) &amp;&amp; (Y == c.Y) &amp;&amp; (Z == c.Z));
            	}
            	public override int GetHashCode ()
            	{
            		return X ^ Y ^ Z;
            	}
            	public static bool operator == (Coord left, Coord right)
            	{
            		return left.Equals (right);
            	}
            	public static bool operator != (Coord left, Coord right)
            	{
            		return !left.Equals (right);
            	}
            }
            </code></example>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OverrideValueTypeDefaultsRule ();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckType">
      <MemberSignature Language="C#" Value="public Gendarme.Framework.RuleResult CheckType (Mono.Cecil.TypeDefinition type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Gendarme.Framework.RuleResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="Mono.Cecil.TypeDefinition" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
