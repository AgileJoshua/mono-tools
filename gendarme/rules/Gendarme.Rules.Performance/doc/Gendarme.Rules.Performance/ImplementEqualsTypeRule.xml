<Type Name="ImplementEqualsTypeRule" FullName="Gendarme.Rules.Performance.ImplementEqualsTypeRule">
  <TypeSignature Language="C#" Value="public class ImplementEqualsTypeRule : Gendarme.Framework.Rule, Gendarme.Framework.ITypeRule" />
  <AssemblyInfo>
    <AssemblyName>Gendarme.Rules.Performance</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Gendarme.Framework.Rule</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Gendarme.Framework.ITypeRule</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Gendarme.Framework.Solution("Implement the suggested method or interface (2.0) to avoid casting and, for ValueType, boxing penalities.")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Gendarme.Framework.Problem("Since this type overrides Equals(object) it is also a good candidate to provide a Equals method for it's own type.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
            This rule looks for types that overrides <c>Object.Equals(object)</c> and that do not
            provide a <c>Equals(x)</c> overload for their own type. Such an overload removes the
            need to cast the object to the correct type. For value types this also remove the
            costly boxing operations. Assemblies targeting the framework 2.0 (and later) should
            also have the type implement <c>System.IEquatable&lt;T&gt;</c>.
            </summary>
    <remarks>This rule is available since Gendarme 2.0</remarks>
    <example>
            Bad example:
            <code>
            public class Bad {
            	public override bool Equals (object obj)
            	{
            		return base.Equals (obj);
            	}
            	public override int GetHashCode ()
            	{
            		return base.GetHashCode ();
            	}
            }
            </code></example>
    <example>
            Good example:
            <code>
            // IEquatable&lt;T&gt; is only available since
            // version 2.0 of the .NET framework
            public class Good : IEquatable&lt;Good&gt; {
            	public override bool Equals (object obj)
            	{
            		return (obj as Good);
            	}
            	public bool Equals (Good other)
            	{
            		return (other != null);
            	}
            	public override int GetHashCode ()
            	{
            		return base.GetHashCode ();
            	}
            }
            </code></example>
    <example>
            Bad example:
            <code>
            public class Bad {
            	public override bool Equals (object obj)
            	{
            		return base.Equals (obj);
            	}
            	public override int GetHashCode ()
            	{
            		return base.GetHashCode ();
            	}
            }
            </code></example>
    <example>
            Good example:
            <code>
            // IEquatable&lt;T&gt; is only available since
            // version 2.0 of the .NET framework
            public class Good : IEquatable&lt;Good&gt; {
            	public override bool Equals (object obj)
            	{
            		return (obj as Good);
            	}
            	public bool Equals (Good other)
            	{
            		return (other != null);
            	}
            	public override int GetHashCode ()
            	{
            		return base.GetHashCode ();
            	}
            }
            </code></example>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ImplementEqualsTypeRule ();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckType">
      <MemberSignature Language="C#" Value="public Gendarme.Framework.RuleResult CheckType (Mono.Cecil.TypeDefinition type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Gendarme.Framework.RuleResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="Mono.Cecil.TypeDefinition" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
