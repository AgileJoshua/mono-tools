<Type Name="RemoveUnneededFinalizerRule" FullName="Gendarme.Rules.Performance.RemoveUnneededFinalizerRule">
  <TypeSignature Language="C#" Value="public class RemoveUnneededFinalizerRule : Gendarme.Framework.Rule, Gendarme.Framework.ITypeRule" />
  <AssemblyInfo>
    <AssemblyName>Gendarme.Rules.Performance</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Gendarme.Framework.Rule</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Gendarme.Framework.ITypeRule</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Gendarme.Framework.FxCopCompatibility("Microsoft.Performance", "CA1821:RemoveEmptyFinalizers")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Gendarme.Framework.Solution("Remove the unneeded finalizer from this type to reduce the GC work.")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Gendarme.Framework.Problem("The type has an unrequired (empty or only nullifying fields) finalizer.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
            This rule looks for types that have empty finalizer (a.k.a. destructor in C# or
            <c>Finalize</c> method). Finalizer that simply nullify fields are considered as
            empty since this does not help the garbage collection. You should remove the empty
            finalizer to reduce the GC involvement (and get better performance) when the object
            instances are freed.
            </summary>
    <remarks>Prior to Gendarme 2.2 this rule was named EmptyDestructorRule</remarks>
    <example>
            Bad example (empty):
            <code>
            class Bad {
            	~Bad ()
            	{
            	}
            }
            </code></example>
    <example>
            Bad example (only nullify fields):
            <code>
            class Bad {
            	object o;
            	~Bad ()
            	{
            		o = null;
            	}
            }
            </code></example>
    <example>
            Good example:
            <code>
            class Good {
            	object o;
            }
            </code></example>
    <example>
            Bad example (empty):
            <code>
            class Bad {
            	~Bad ()
            	{
            	}
            }
            </code></example>
    <example>
            Bad example (only nullify fields):
            <code>
            class Bad {
            	object o;
            	~Bad ()
            	{
            		o = null;
            	}
            }
            </code></example>
    <example>
            Good example:
            <code>
            class Good {
            	object o;
            }
            </code></example>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RemoveUnneededFinalizerRule ();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckType">
      <MemberSignature Language="C#" Value="public Gendarme.Framework.RuleResult CheckType (Mono.Cecil.TypeDefinition type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Gendarme.Framework.RuleResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="Mono.Cecil.TypeDefinition" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
