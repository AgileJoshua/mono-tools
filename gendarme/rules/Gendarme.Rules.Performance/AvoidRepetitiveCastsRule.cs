//
// Gendarme.Rules.Performance.AvoidRepetitiveCastsRule
//
// Authors:
//	Sebastien Pouliot <sebastien@ximian.com>
//
// Copyright (C) 2008 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using System;
using System.Collections.Generic;

using Mono.Cecil;
using Mono.Cecil.Cil;

using Gendarme.Framework;
using Gendarme.Framework.Engines;
using Gendarme.Framework.Helpers;
using Gendarme.Framework.Rocks;

namespace Gendarme.Rules.Performance {

	/// <summary>
	/// This rule warns when a structure is larger than a a maximum value (default to
	/// 16 bytes). Large structure can cause performance problems since they are value types
	/// and as such are copied by copying the whole value (size dependent) while reference 
	/// types can be copied by only copying its reference (constant size). If the structure 
	/// cannot be reduced in size (e.g. by removing calculated fields) then it should be 
	/// turned into a class.
	/// </summary>
	/// <example>
	/// Bad example:
	/// <code>
	/// public struct BigArgb {
	///	long a, r, g, b;
	/// }
	/// </code>
	/// </example>
	/// <example>
	/// Good example:
	/// <code>
	/// public class BigArgb {
	///	long a, r, g, b;
	/// }
	/// </code>
	/// </example>
	/// <remarks>This rule is available since Gendarme 2.0</remarks>

	[Problem ("The method seems to repeat the same cast operation multiple times.")]
	[Solution ("Change the logic to make sure the (somewhat expensive) cast is done a single time.")]
	[EngineDependency (typeof (OpCodeEngine))]
	[FxCopCompatibility ("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
	public class AvoidRepetitiveCastsRule : Rule, IMethodRule {

		List<Instruction> casts = new List<Instruction> ();

		static object GetOrigin (Instruction ins, MethodDefinition method)
		{
			Instruction previous = ins.Previous;

			bool call = (previous.OpCode.FlowControl == FlowControl.Call);
			if (call) {
				Instruction next = ins.Next;
				if (next.IsStoreLocal ())
					return ins.Next.GetOperand (method);
			}

			if (call || previous.IsLoadElement () || previous.IsLoadIndirect ())
				return previous.TraceBack (method).GetOperand (method);

			return previous.GetOperand (method);
		}

		private int FindDuplicates (MethodDefinition method, string type, object origin)
		{
			// we already had our first cast if we got here
			int count = 1;

			// don't check 0 since it's the one we compare with
			for (int i = 1; i < casts.Count; i++) {
				Instruction ins = casts [i];
				if (type != (ins.Operand as TypeReference).FullName)
					continue;
				if (origin != GetOrigin (ins, method))
					continue;
				// we're removing this so we need to adjust the counter
				// important since we don't want duplicate reports
				casts.RemoveAt (i);
				i--;
				count++;
			}
			return count;
		}

		static OpCodeBitmask Casts = new OpCodeBitmask (0x0, 0x18000000000000, 0x0, 0x0);

		public RuleResult CheckMethod (MethodDefinition method)
		{
			// rule apply only if the method has a body (e.g. p/invokes, icalls don't)
			// and was not generated by the compiler or a tool (outside of developer's control)
			if (!method.HasBody || method.IsGeneratedCode ())
				return RuleResult.DoesNotApply;

			// is there any IsInst or Castclass instructions in the method ?
			if (!Casts.Intersect (OpCodeEngine.GetBitmask (method)))
				return RuleResult.DoesNotApply;

			foreach (Instruction ins in method.Body.Instructions) {
				Code code = ins.OpCode.Code;
				// IsInst -> if (t is T) ...
				// Castclass -> t = (T) t; ...
				if ((code == Code.Isinst) || (code == Code.Castclass))
					casts.Add (ins);
			}

			// if there's only one then it can't be a duplicate cast
			while (casts.Count > 1) {
				Instruction ins = casts [0];
				string type = (ins.Operand as TypeReference).FullName;
				object origin = GetOrigin (ins, method);

				int count = FindDuplicates (method, type, origin);
				if (count > 1) {
					// rare, but it's possible to cast a null value (ldnull)
					string name = origin == null ? "Null" : origin.ToString ();
					string msg = String.Format ("'{0}' is casted {1} times for type '{2}'.", name, count, type);
					Runner.Report (method, ins, Severity.Medium, Confidence.Normal, msg);
				}
				casts.RemoveAt (0);
			}
			casts.Clear ();

			return Runner.CurrentRuleResult;
		}
#if false
		public void Bitmask ()
		{
			OpCodeBitmask casts = new OpCodeBitmask ();
			casts.Set (Code.Castclass);
			casts.Set (Code.Isinst);
			Console.WriteLine (casts);
		}
#endif
	}
}
